«IMPORT ecdarText»
«DEFINE main FOR ecdarText::ETSpecificationDefinition»
«REM»
   «DEFINE main FOR ecdarText::ETSpecificationDefinition»
«ENDREM»
«FILE this.name + ".java"»

package dk.itu.ecdar.text.generator.mockup;
import dk.itu.ecdar.text.generator.framework.IInputEdge;
import dk.itu.ecdar.text.generator.framework.IOutputEdge;
import dk.itu.ecdar.text.generator.framework.ILocation;
import dk.itu.ecdar.text.generator.framework.ITIOA;

public class «this.name» extends ITIOA {

«REM»
   Iterate over this specifications locations edges
«ENDREM»

/* Generating all edges */
«FOREACH body.locations.edges AS edge ITERATOR iter»
   	/*	Number: «iter.counter1»
 		Name: «edge.toString()» of edge
 		Controllable: «edge.controllable» 	*/
 		
   	«IF (edge.controllable)»
   	class «iter.counter1» extends IInputEdge {
   	«ELSE»
   	class «iter.counter1» extends IOutputEdge {
   	«ENDIF»    	 
		public «iter.counter1»() {
			//super(A, B, "grant");

			// Edge properties

			«FOREACH edge.updates AS io ITERATOR iter3»
			«io.eAllContents.toString()»
			«ENDFOREACH»
			
			// testing target
			«edge.target.name»
			
		}

		@Override
		public boolean checkGuard(long time) {
			return to.checkInvariant(time);
		}

		@Override
		public void onTraverse() {
			resetTime();
		}
	} 
«ENDFOREACH»

«REM»
   initial location Name: «this.body.initialLocation.name»
«ENDREM»
«REM»First we add the initial location to the list of locations«ENDREM»
//«body.locations.add(this.body.initialLocation)»

/* Generating all locations */
«FOREACH body.locations.reverse() AS location ITERATOR iter»
   	/* 	Number: «iter.counter1» 
   		Name: «location.name.toString()» */
   		
	class «location.name» extends ILocation {
		public «location.name»(University parent) {
			super("«location.name»", parent);
		}

		@Override
		public void setupEdges() {
			outputEdges = new IOutputEdge[]{
				«FOREACH location.edges AS edge»
					«IF edge.controllable == false»
						«REM»We have the uncontrollable edges here«ENDREM»
						//«edge»
					«ENDIF»					
				«ENDFOREACH»
			};
			
			inputEdges = new IInputEdge[]{
				«REM»new A_GRANT_B()«ENDREM»
				«FOREACH location.edges AS edge»
					«IF edge.controllable»
						«REM»We have the controllable edges here«ENDREM»
						//«edge»
					«ENDIF»					
				«ENDFOREACH»
			};
		}

		@Override
		public boolean checkInvariant(long time) {
			«IF (!location.invariants.isEmpty)»
			//IS NOT EMPTY
				«LET location.invariants.eContents.typeSelect(ETNumberLiteral).value.get(0) AS invariantValue»
				return time
				«IF location.invariants.get(0).metaType == ecdarText::ETLessEqualExpression»
				<=
				«ENDIF»
				«invariantValue»;
				«ENDLET»
			«ELSE»
			//IS EMPTY
			return true;
			«ENDIF»			
		}

		@Override
		public boolean isPreemptive() {
			//Is always false atm
			return false;
		}

		@Override
		public void task() {
			//Is empty??
		}	
	}
«ENDFOREACH»
	«REM»Instantiate«ENDREM»
	ILocation «FOREACH body.locations.withoutLast() AS location ITERATOR iter»«location.name.toString()», «ENDFOREACH»«body.locations.last().name.toString()»;
	
	public «this.name»() {
		super();
		«FOREACH body.locations.reverse() AS location ITERATOR iter»
		«location.name.toString()» = new «location.name.toString()»(this);
		«location.name.toString()».setupEdges();
		«ENDFOREACH»
		current = «body.locations.last().name.toString()»;
	}
}
«ENDFILE»
«ENDDEFINE»
